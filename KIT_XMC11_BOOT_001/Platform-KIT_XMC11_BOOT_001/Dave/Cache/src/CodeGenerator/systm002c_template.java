package CodeGenerator;

import java.util.*;
import com.ifx.davex.appjetinteract.App2JetInterface;

public class systm002c_template
{
  protected static String nl;
  public static synchronized systm002c_template create(String lineSeparator)
  {
    nl = lineSeparator;
    systm002c_template result = new systm002c_template();
    nl = null;
    return result;
  }

  public final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = "/*CODE_BLOCK_BEGIN[SYSTM002.c]*/" + NL + "/******************************************************************************" + NL + " * @file     SYSTM002.c" + NL + " * @brief    SCU_SystemTimer_SYSTM002 App implementation file. This App provides" + NL + " *            API's for create, start, stop and delete software timers." + NL + " * @version  V1.0.0" + NL + " * @date     25 Sep 2013" + NL + " *" + NL + " * @note" + NL + " * Copyright (C) 2012-2013 Infineon Technologies AG. All rights reserved." + NL + "" + NL + " *" + NL + " * @par" + NL + " * Infineon Technologies AG (Infineon) is supplying this software for use with" + NL + " * Infineon's microcontrollers." + NL + " *" + NL + " * This file can be freely distributed within development tools that are" + NL + " * supporting such microcontrollers." + NL + " *" + NL + " *" + NL + " * @par" + NL + " * THIS SOFTWARE IS PROVIDED \"AS IS\".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED" + NL + " * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF" + NL + " * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE." + NL + " * INFINEON SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL," + NL + " * OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER." + NL + " *" + NL + " ******************************************************************************/" + NL + "/*" + NL + " * *************************** Change history ********************************" + NL + " * V1.0.0,\t25-Sep-13\t Initial Version" + NL + " " + NL + " * *************************** Change history ********************************" + NL + " */" + NL + " /* Inclusion of header file */" + NL + "#include \"DAVE3.h\"" + NL;
  protected final String TEXT_2 = NL;
  protected final String TEXT_3 = "  " + NL + "/*****************************************************************************" + NL + "              DUMMY DEFINTIONS OF DEBUG LOG MACROS" + NL + "*****************************************************************************/" + NL + "/*These definitions are included here to avoid compilation errors," + NL + " since the DBG002 app is not part of the project. All the macros are defined" + NL + " as empty*/ " + NL + "#ifndef _DBG002_H_" + NL + "" + NL + "#define DBG002_RegisterCallBack(A,B,C)" + NL + "#define DBG002_I(e) " + NL + "#define DBG002_IG(e,g) " + NL + "#define DBG002_IH(e,h) " + NL + "#define DBG002_IP(e,p) " + NL + "#define DBG002_IGH(e,g,h) " + NL + "#define DBG002_IGP(e,g,p) " + NL + "#define DBG002_IHP(e,h,p) " + NL + "#define DBG002_IGHP(e,g,h,p) " + NL + "#define DBG002_N(e) " + NL + "#define DBG002_NG(e,g) " + NL + "#define DBG002_NH(e,h) " + NL + "#define DBG002_NP(e,p) " + NL + "#define DBG002_NGH(e,g,h) " + NL + "#define DBG002_NGP(e,g,p) " + NL + "#define DBG002_NHP(e,h,p) " + NL + "#define DBG002_NGHP(e,g,h,p) " + NL + "#define DBG002_ID(e) " + NL + "#define DBG002_IS(e) " + NL + "#define DBG002_ISG(e,g) " + NL + "#define DBG002_SAFETY_CRITICAL(groupid,messageid,length,value)" + NL + "#define DBG002_CRITICAL(groupid,messageid,length,value)" + NL + "#define DBG002_ERROR(groupid,messageid,length,value)" + NL + "#define DBG002_WARNING(groupid,messageid,length,value)" + NL + "#define DBG002_INFO(groupid,messageid,length,value)" + NL + "#define DBG002_TRACE(groupid,messageid,length,value)" + NL + "#define DBG002_FUNCTION_ENTRY(GID, Status) " + NL + "#define DBG002_FUNCTION_EXIT(GID, Status) " + NL + "" + NL + "#endif/* End of defintions of dummy Debug Log macros*/";
  protected final String TEXT_4 = "                  " + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Private Macro Definitions                             **" + NL + "*******************************************************************************/" + NL + "#define APP_GID DBG002_GID_SYSTM002" + NL + "#define HW_TIMER_ADDITIONAL_CNT (1U)" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Private Type Definitions                              **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                 Private Function Declarations:" + NL + "*******************************************************************************/" + NL + "" + NL + " " + NL + "/**" + NL + " * @brief      This function is called to insert a timer into the timer list.  " + NL + " *        " + NL + " * @param[in]  Index Timer ID" + NL + " * @return     none" + NL + " *      " + NL + " * <b>Reentrant: NO </b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " */" + NL + "static void  SYSTM002_lInsertTimerList (uint32_t Index);" + NL + "" + NL + "" + NL + "/*" + NL + " * @brief      This function is called to remove a timer from the timer list. " + NL + " *              " + NL + " * @param[in]  Index Timer ID" + NL + " * @return     none" + NL + " *      " + NL + " * <b>Reentrant: NO </b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " */" + NL + "static void  SYSTM002_lRemoveTimerList(uint32_t Index);" + NL + "" + NL + "/*" + NL + " * @brief      Handler function  called from Systick event handler. " + NL + " *              " + NL + " * @return     void " + NL + " *      " + NL + " * <b>Reentrant: NO </b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " */" + NL + "static void  SYSTM002_lTimerHandler (void);" + NL + "" + NL + "/*" + NL + " * @brief      Systick  handler" + NL + " *              " + NL + " * @return     void " + NL + " *      " + NL + " * <b>Reentrant: NO </b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " */" + NL + "void  SysTick_Handler (void);" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Global Constant Definitions                           **" + NL + "*******************************************************************************/" + NL + "" + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Global Variable Definitions                           **" + NL + "*******************************************************************************/" + NL + "" + NL + "" + NL + "/** Table which save timer control block. */" + NL + "SYSTM002_TimerObject TimerTbl[SYSTM002_CFG_MAX_TMR];" + NL + "" + NL + "/** The header of the Timer Control list.      */" + NL + "SYSTM002_TimerObject*  TimerList = 0;" + NL + "" + NL + " /**   Timer ID Tracker  */" + NL + "uint32_t TimerTracker = 0UL;" + NL + "" + NL + "/** SysTick Counter */" + NL + "uint32_t SysTickCount = 0UL;" + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Private Constant Definitions                          **" + NL + "*******************************************************************************/" + NL + "" + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + "**                 Function like macro definitions                            **" + NL + "*******************************************************************************/" + NL + "" + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Private Function Definitions                          **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*" + NL + " * This function is called to insert a timer into the timer list." + NL + " */" + NL + "static void  SYSTM002_lInsertTimerList (uint32_t Index)" + NL + "{" + NL + "  SYSTM002_TimerObject* TmrObjPtr;" + NL + "  int32_t DeltaTicks;" + NL + "  uint32_t TempTmrCnt;" + NL + "   /* Get timer time */" + NL + "  TempTmrCnt = TimerTbl[Index].TimerCount;" + NL + "  /* Check if timer count is zero */" + NL + "  /* <<<DD_SYSTM002_PRIV _API_1>>> */" + NL + "" + NL + "  /* Check if Timer list is NULL */" + NL + "  if(TimerList == NULL)" + NL + "  {" + NL + "      /* Set this as first Timer */" + NL + "      TimerList = &TimerTbl[Index];" + NL + "  }" + NL + "  /* IF Not, find the correct place ,and insert the specified timer */" + NL + "  else" + NL + "  {" + NL + "    TmrObjPtr = TimerList;" + NL + "    /* Get timer tick */" + NL + "    DeltaTicks = (int32_t)TempTmrCnt;" + NL + "    /* Find correct place for inserting the timer */" + NL + "    while(TmrObjPtr != NULL)" + NL + "    {" + NL + "      /* Get timer Count Difference  */" + NL + "      DeltaTicks -= (int32_t)TmrObjPtr->TimerCount;" + NL + "      /* Is delta ticks<0? */" + NL + "      if(DeltaTicks < 0)" + NL + "      {" + NL + "        /*  Check If head item */" + NL + "        if(TmrObjPtr->TimerPrev!= NULL)" + NL + "        {" + NL + "          /* If Insert to list */" + NL + "          TmrObjPtr->TimerPrev->TimerNext = &TimerTbl[Index];" + NL + "          TimerTbl[Index].TimerPrev = TmrObjPtr->TimerPrev;" + NL + "          TimerTbl[Index].TimerNext = TmrObjPtr;" + NL + "          TmrObjPtr->TimerPrev = &TimerTbl[Index];" + NL + "        }" + NL + "        else" + NL + "        {" + NL + "          /* Set Timer as first item */" + NL + "          TimerTbl[Index].TimerNext = TimerList;" + NL + "          TimerList->TimerPrev = &TimerTbl[Index];" + NL + "          TimerList = &TimerTbl[Index];" + NL + "        }" + NL + "        TimerTbl[Index].TimerCount = \\" + NL + "                TimerTbl[Index].TimerNext->TimerCount + (uint32_t)DeltaTicks;" + NL + "        TimerTbl[Index].TimerNext->TimerCount  -= TimerTbl[Index].TimerCount;" + NL + "        break;" + NL + "      }" + NL + "      /* Is last item in list? */" + NL + "      else" + NL + "      {" + NL + "        if((DeltaTicks >= 0) && (TmrObjPtr->TimerNext == NULL))" + NL + "        {" + NL + "          /* Yes,insert into */" + NL + "          TimerTbl[Index].TimerPrev = TmrObjPtr;" + NL + "          TmrObjPtr->TimerNext = &TimerTbl[Index];" + NL + "          TimerTbl[Index].TimerCount = (uint32_t)DeltaTicks;" + NL + "          break;" + NL + "        }" + NL + "      }" + NL + "      /* Get the next item in timer list    */" + NL + "      TmrObjPtr = TmrObjPtr->TimerNext;" + NL + "    }" + NL + "  }" + NL + "}" + NL + "" + NL + "" + NL + "/*" + NL + " * This function is called to remove a timer from the timer list. " + NL + " */" + NL + "static void  SYSTM002_lRemoveTimerList(uint32_t Index)" + NL + "{" + NL + "  SYSTM002_TimerObject* TmrObjPtr;" + NL + "  TmrObjPtr = &TimerTbl[Index];" + NL + "  /* Check whether only one timer available */" + NL + "  /* <<<DD_SYSTM002_PRIV _API_2>>> */" + NL + "  if((TmrObjPtr->TimerPrev == NULL) && (TmrObjPtr->TimerNext == NULL))" + NL + "  {" + NL + "    /* set timer list as NULL */ " + NL + "    TimerList = NULL;                 \t" + NL + "  }" + NL + "   /* Check if the first item in timer list   */" + NL + "  else if(TmrObjPtr->TimerPrev == NULL)     " + NL + "  {   " + NL + "    /* Remove timer from list,and reset timer list */" + NL + "    TimerList  = TmrObjPtr->TimerNext;" + NL + "    TimerList->TimerPrev = NULL;" + NL + "    TmrObjPtr->TimerNext->TimerCount += TmrObjPtr->TimerCount;" + NL + "    TmrObjPtr->TimerNext    = NULL;  " + NL + "  }" + NL + "  /* Check if the last item in timer list   */" + NL + "  else if(TmrObjPtr->TimerNext == NULL)      " + NL + "  {" + NL + "    /* Remove timer from list */" + NL + "    TmrObjPtr->TimerPrev->TimerNext = NULL;\t" + NL + "    TmrObjPtr->TimerPrev = NULL;" + NL + "  }" + NL + "  else                                /*  remove timer from list         */" + NL + "  {" + NL + "    /*  Remove timer from list */" + NL + "    TmrObjPtr->TimerPrev->TimerNext  =  TmrObjPtr->TimerNext;" + NL + "    TmrObjPtr->TimerNext->TimerPrev  =  TmrObjPtr->TimerPrev;" + NL + "    TmrObjPtr->TimerNext->TimerCount  += TmrObjPtr->TimerCount;" + NL + "    TmrObjPtr->TimerNext = NULL;" + NL + "    TmrObjPtr->TimerPrev = NULL;" + NL + "  }" + NL + "}" + NL + "" + NL + "/*" + NL + " * Handler function  called from Systick event handler. " + NL + " */" + NL + "static void  SYSTM002_lTimerHandler (void)" + NL + "{" + NL + "  SYSTM002_TimerObject* TmrObjPtr;" + NL + "   /* Get first item of timer list       */" + NL + "  TmrObjPtr = TimerList;         " + NL + "  /* <<<DD_SYSTM002_PRIV _API_3>>> */  " + NL + "  while((TmrObjPtr != NULL) && (TmrObjPtr->TimerCount == 0UL) )" + NL + "  {\t" + NL + "    /* Check whether timer is a one shot timer */" + NL + "    if(TmrObjPtr->TimerType == SYSTM002_ONE_SHOT)" + NL + "    {" + NL + "      /* Yes,remove this timer from timer list */" + NL + "      SYSTM002_lRemoveTimerList(TmrObjPtr->TimerID);" + NL + "      /* Set timer status as SYSTM002_STATE_STOPPED */" + NL + "      TmrObjPtr->TimerState = SYSTM002_STATE_STOPPED;" + NL + "      /* Call timer callback function */" + NL + "      (TmrObjPtr->TimerCallBack)(TmrObjPtr->ParamToCallBack);" + NL + "    }" + NL + "    /* Check whether timer is SYSTM002_PERIODIC */" + NL + "    else if(TmrObjPtr->TimerType == SYSTM002_PERIODIC)" + NL + "    {" + NL + "      /* Yes,remove this timer from timer list */" + NL + "      SYSTM002_lRemoveTimerList(TmrObjPtr->TimerID);" + NL + "      /* Reset timer tick             */" + NL + "      TmrObjPtr->TimerCount = TmrObjPtr->TimerReload;" + NL + "        /* Insert timer into timer list */" + NL + "      SYSTM002_lInsertTimerList(TmrObjPtr->TimerID);" + NL + "      /* Call timer callback function */" + NL + "      (TmrObjPtr->TimerCallBack)(TmrObjPtr->ParamToCallBack);" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "    /* Get first item of timer list */" + NL + "    TmrObjPtr = TimerList;" + NL + "  }" + NL + "}" + NL + "" + NL + "/*" + NL + " *  SysTick Event Handler " + NL + " */" + NL + "void  SysTick_Handler(void)" + NL + "{ " + NL + "  SYSTM002_TimerObject* TmrObjPtr;" + NL + "  TmrObjPtr = TimerList;" + NL + "  /* <<<DD_SYSTM002_PRIV _API_4>>> */" + NL + "  SysTickCount++;" + NL + "" + NL + "  if(TmrObjPtr == NULL)" + NL + "  {" + NL + "    /* Not supposed to be here */" + NL + "    DBG002_ERROR(APP_GID,SYSTM002_INVALID_HANDLE_ERROR, 0, NULL);" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    if(TmrObjPtr->TimerCount > 1UL)" + NL + "    {" + NL + "      TmrObjPtr->TimerCount--;" + NL + "    }" + NL + "    else" + NL + "    { " + NL + "      TmrObjPtr->TimerCount = 0;" + NL + "      SYSTM002_lTimerHandler();" + NL + "    }" + NL + "  }" + NL + "}" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Public Function Definitions                           **" + NL + "*******************************************************************************/" + NL + "" + NL + "" + NL + "/** @ingroup Simple_System_Timer_App PublicFunc" + NL + " * @{" + NL + " */" + NL + " " + NL + "/*" + NL + " *  Initialization function which initializes the App internal data" + NL + " *  structures to default values. " + NL + " */" + NL + "void  SYSTM002_Init( void)" + NL + "{" + NL + "    uint32_t Status = 0UL;";
  protected final String TEXT_5 = NL + "  DBG002_FUNCTION_ENTRY(APP_GID,SYSTM002_FUNCTION_ENTRY);" + NL + "   /* <<<DD_SYSTM002 _API_1>>> */" + NL + "  /** Initialize the header of the list */" + NL + "  TimerList = NULL;" + NL + "  /**   Initialize timer tracker  */" + NL + "  Status = SysTick_Config((uint32_t)(SYSTM002_SYSTICK_INTERVAL * SYSTM002_SYS_CORE_CLOCK));" + NL + "  if(Status == 1U)" + NL + "  {" + NL + "        DBG002_ERROR(APP_GID,SYSTM002_ERROR, 0, NULL);" + NL + "  }";
  protected final String TEXT_6 = NL + "    NVIC_SetPriority(SysTick_IRQn, ";
  protected final String TEXT_7 = ");";
  protected final String TEXT_8 = NL + "    NVIC_SetPriority(SysTick_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),";
  protected final String TEXT_9 = ",";
  protected final String TEXT_10 = "));";
  protected final String TEXT_11 = NL + "  TimerTracker = 0UL;" + NL + "  DBG002_FUNCTION_EXIT(APP_GID,SYSTM002_FUNCTION_EXIT);" + NL + "}" + NL + "" + NL + "/*" + NL + " *  Interface for creating a new software Timer instance." + NL + " *  Note: Because of invocation of SYSTM002_Init() : Timer reload value " + NL + " *  programmed, Hardware System Timer started. Software Timer will be created" + NL + " *  using SYSTM002_CreateTimer(). Due to time at which SW timer creation asked" + NL + " *  by user will not be in sync with HW timer, the count value used below with" + NL + " *  SW Timer, will not create starting/initial period same as expected value." + NL + " *  To SW timer period (Initial one) equal to more than expected, it is decided" + NL + " *  to add one extra count(HW_TIMER_ADDITIONAL_CNT) with Software timer." + NL + " *" + NL + " *  Impact: Impact of this additional count(HW_TIMER_ADDITIONAL_CNT) is," + NL + " *  First SW Timer period is always equal to or more than expected/configured. " + NL + " */" + NL + "handle_t SYSTM002_CreateTimer" + NL + "(" + NL + "  uint32_t Period," + NL + "  SYSTM002_TimerType TimerType, " + NL + "  SYSTM002_TimerCallBackPtr TimerCallBack, " + NL + "  void  * pCallBackArgPtr" + NL + ")" + NL + "{" + NL + "  uint32_t TimerID = 0UL;" + NL + "  uint32_t Count = 0UL;" + NL + "  uint32_t Error = 0UL;  " + NL + "  /* <<<DD_SYSTM002 _API_2>>> */" + NL + "  DBG002_FUNCTION_ENTRY(APP_GID,SYSTM002_FUNCTION_ENTRY);" + NL + "  /* Check for input parameter */" + NL + "    if((TimerType != SYSTM002_ONE_SHOT) && (TimerType != SYSTM002_PERIODIC))" + NL + "    {" + NL + "      DBG002_ERROR(GID_SYSTM002,SYSTM002_INVALID_HANDLE_ERROR, 0, NULL);" + NL + "      Error=(uint32_t)1UL;" + NL + "    }" + NL + "    if(Period < (uint32_t)SYSTM002_SYSTICK_INTERVAL)" + NL + "    {" + NL + "      DBG002_ERROR(GID_SYSTM002,SYSTM002_INVALID_HANDLE_ERROR, 0, NULL);" + NL + "      Error=(uint32_t)1UL;" + NL + "    }" + NL + "    if(Period == 0)          /* Timer with '0' time is not allowed. */" + NL + "    {" + NL + "      DBG002_ERROR(GID_SYSTM002,SYSTM002_INVALID_HANDLE_ERROR, 0, NULL);" + NL + "      Error=(uint32_t)1UL;" + NL + "    }" + NL + "" + NL + "    if(TimerCallBack == NULL)" + NL + "    {" + NL + "      DBG002_ERROR(GID_SYSTM002,SYSTM002_INVALID_HANDLE_ERROR, 0, NULL);" + NL + "      Error=(uint32_t)1UL;" + NL + "    }" + NL + "    if (!Error)\t" + NL + "    {" + NL + "       for(Count = 0UL; Count < SYSTM002_CFG_MAX_TMR; Count++)" + NL + "       {" + NL + "           /* Check for free timer ID */" + NL + "           if((TimerTracker & ((uint32_t)1U << Count)) == 0U)" + NL + "           {" + NL + "               /* If yes,assign ID to this timer      */" + NL + "               TimerTracker |= ((uint32_t)1U << Count);" + NL + "               /* Initialize timer as per input values */" + NL + "               TimerTbl[Count].TimerID     = Count;" + NL + "               TimerTbl[Count].TimerType   = TimerType;" + NL + "               TimerTbl[Count].TimerState  = SYSTM002_STATE_STOPPED;" + NL + "             TimerTbl[Count].TimerCount  = ((Period / SYSTM002_SYSTICK_INTERVAL)\\" + NL + "                                                    +HW_TIMER_ADDITIONAL_CNT);" + NL + "               TimerTbl[Count].TimerReload\t= (Period / SYSTM002_SYSTICK_INTERVAL);" + NL + "               TimerTbl[Count].TimerCallBack = TimerCallBack;" + NL + "               TimerTbl[Count].ParamToCallBack = pCallBackArgPtr;" + NL + "               TimerTbl[Count].TimerPrev   = NULL;" + NL + "               TimerTbl[Count].TimerNext   = NULL;" + NL + "               TimerID = Count + 1U;" + NL + "               break;" + NL + "            }" + NL + "        }" + NL + "    }" + NL + "  DBG002_FUNCTION_EXIT(APP_GID,SYSTM002_FUNCTION_EXIT);" + NL + "  return (handle_t)TimerID;" + NL + "}  " + NL + "" + NL + "/*" + NL + " *  Interface to start the software timer ." + NL + " */" + NL + "status_t SYSTM002_StartTimer(handle_t  Handle) " + NL + "{" + NL + "  status_t Error = (status_t )DAVEApp_SUCCESS;" + NL + "  /* <<<DD_SYSTM002 _API_3>>> */" + NL + "  DBG002_FUNCTION_ENTRY(APP_GID,SYSTM002_FUNCTION_ENTRY);" + NL + "" + NL + "  /* Check validity of parameter */" + NL + "  if(Handle > SYSTM002_CFG_MAX_TMR)" + NL + "  {" + NL + "    Error = (status_t)SYSTM002_INVALID_HANDLE_ERROR;" + NL + "    DBG002_ERROR(APP_GID,Error, 0, NULL);" + NL + "  }" + NL + "  if( (TimerTracker & (1UL << (uint32_t)(Handle - 1U))) == 0UL)" + NL + "  {" + NL + "    Error = (status_t) SYSTM002_INVALID_HANDLE_ERROR;" + NL + "    DBG002_ERROR(APP_GID,Error, 0, NULL);" + NL + "  }" + NL + "  /* Any timer with time '0', can't start again. */" + NL + "  if(TimerTbl[Handle - 1U].TimerCount == 0UL)" + NL + "  {" + NL + "    Error = (status_t) SYSTM002_INVALID_HANDLE_ERROR;" + NL + "    DBG002_ERROR(APP_GID,Error, 0, NULL);" + NL + "  }" + NL + "  " + NL + "  " + NL + "  if(Error == (status_t)DAVEApp_SUCCESS)" + NL + "  {" + NL + "    /* Check if timer is running */" + NL + "    if(TimerTbl[(Handle - 1U)].TimerState != SYSTM002_STATE_RUNNING)" + NL + "    {" + NL + "      /* set timer status as SYSTM002_STATE_RUNNING */" + NL + "      TimerTbl[(Handle - 1U)].TimerState = SYSTM002_STATE_RUNNING;" + NL + "      /* Insert this timer into timer list  */" + NL + "      SYSTM002_lInsertTimerList((Handle - 1U));" + NL + "    }" + NL + "  }" + NL + "" + NL + "  DBG002_FUNCTION_EXIT(APP_GID,SYSTM002_FUNCTION_EXIT);" + NL + "  return Error;" + NL + "}" + NL + "" + NL + "" + NL + "/*" + NL + " *  Interface to stop the software timer." + NL + " */" + NL + "status_t SYSTM002_StopTimer(handle_t Handle) " + NL + "{" + NL + "  status_t Error = (status_t )DAVEApp_SUCCESS;" + NL + "  /* <<<DD_SYSTM002 _API_4>>> */" + NL + "  DBG002_FUNCTION_ENTRY(APP_GID,SYSTM002_FUNCTION_ENTRY);" + NL + "" + NL + "  /* Check validity of parameter        */" + NL + "  if(Handle > SYSTM002_CFG_MAX_TMR)" + NL + "  {" + NL + "    Error = (status_t) SYSTM002_INVALID_HANDLE_ERROR;" + NL + "    DBG002_ERROR(APP_GID,Error, 0, NULL);" + NL + "  }" + NL + "  if( (TimerTracker & (1UL << (uint32_t)(Handle - 1U))) == 0UL)" + NL + "  {" + NL + "    Error = (status_t) SYSTM002_INVALID_HANDLE_ERROR;" + NL + "    DBG002_ERROR(APP_GID,Error, 0, NULL);" + NL + "  }" + NL + "" + NL + "  if(Error == (status_t)DAVEApp_SUCCESS)" + NL + "  {" + NL + "    /* Check whether Timer is in Stop state */" + NL + "    if(TimerTbl[(Handle - 1U)].TimerState != SYSTM002_STATE_STOPPED)" + NL + "    {" + NL + "      /* remove Timer from node list */" + NL + "      SYSTM002_lRemoveTimerList((Handle - 1U));" + NL + "" + NL + "      /* Set timer status as SYSTM002_STATE_STOPPED  */" + NL + "      TimerTbl[(Handle - 1U)].TimerState = SYSTM002_STATE_STOPPED;" + NL + "    }" + NL + "  }" + NL + "" + NL + "  DBG002_FUNCTION_EXIT(APP_GID,SYSTM002_FUNCTION_EXIT);" + NL + "  return Error;" + NL + "}" + NL + "" + NL + "/*" + NL + " *  Function to delete the Timer instance." + NL + " */" + NL + "status_t SYSTM002_DeleteTimer(handle_t Handle) " + NL + "{" + NL + "  status_t Error = (status_t )DAVEApp_SUCCESS;" + NL + "  /* <<<DD_SYSTM002 _API_5>>> */" + NL + "  DBG002_FUNCTION_ENTRY(APP_GID,SYSTM002_FUNCTION_ENTRY);" + NL + "" + NL + "  /* Check validity of parameter        */" + NL + "  if(Handle > SYSTM002_CFG_MAX_TMR)" + NL + "  {" + NL + "    Error = (status_t) SYSTM002_INVALID_HANDLE_ERROR;" + NL + "    DBG002_ERROR(APP_GID,Error, 0, NULL);" + NL + "  }" + NL + "  if( (TimerTracker & (1UL << (uint32_t)(Handle - 1U))) == 0UL)" + NL + "  {" + NL + "    Error = (status_t) SYSTM002_INVALID_HANDLE_ERROR;" + NL + "    DBG002_ERROR(APP_GID,Error, 0, NULL);" + NL + "  }" + NL + "" + NL + "  if(Error == (status_t)DAVEApp_SUCCESS)" + NL + "  {" + NL + "    /* Check if timer is running */" + NL + "    if(TimerTbl[(Handle - 1U)].TimerState == SYSTM002_STATE_RUNNING)" + NL + "    {" + NL + "      /* Yes,remove this timer from timer list*/" + NL + "      SYSTM002_lRemoveTimerList((Handle - 1U));" + NL + "    }" + NL + "" + NL + "    /* Release resource that this timer hold*/" + NL + "    TimerTracker &=~((uint32_t)1U << (Handle - 1U));" + NL + "  }" + NL + "" + NL + "  DBG002_FUNCTION_EXIT(APP_GID,SYSTM002_FUNCTION_EXIT);" + NL + "  return Error;" + NL + "" + NL + "}" + NL + "" + NL + "/*" + NL + " *  Interface to get the current system time." + NL + " */" + NL + "uint32_t  SYSTM002_GetTime(void)" + NL + "{" + NL + "  /* <<<DD_SYSTM002 _API_6>>> */" + NL + "  return CONVERT_SYSTICK_COUNT_TO_USEC(SysTickCount);" + NL + "}" + NL + "" + NL + "/*" + NL + " *  Utility function to get the no of system ticks for the " + NL + " *  specified period." + NL + " */" + NL + "uint32_t  SYSTM002_GetSysTickCount(uint32_t Period ) " + NL + "{" + NL + "  /* <<<DD_SYSTM002 _API_7>>> */" + NL + "  uint32_t\tCount  = CONVERT_USEC_TO_SYSICK_COUNT(Period);" + NL + "  return Count;" + NL + "}" + NL + "" + NL + "" + NL + "" + NL + "" + NL + "/*CODE_BLOCK_END*/" + NL;
  protected final String TEXT_12 = NL;

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
     App2JetInterface app = (App2JetInterface) argument; 
     String AppBaseuri = "app/systm002/0";
    stringBuffer.append(TEXT_1);
     String TempApps = null;
   String MyAppName = null;
   ArrayList<String> apps;
   String TempLowerApps = null; 
   boolean DBGApp = false;   
   apps=(ArrayList<String>)(app.getApps());
        for (int k = 0; k < apps.size(); k++) {
              TempApps = apps.get(k);
//            if(app.isAppInitProvider(apps.get(k)) == true) {
              MyAppName = TempApps.substring(TempApps.indexOf("/app/") + 5, TempApps.lastIndexOf("/"));
              TempLowerApps = MyAppName.toLowerCase();
              if (TempLowerApps.equalsIgnoreCase("dbg002")) {DBGApp = true;}   
//   }  
  } 
    stringBuffer.append(TEXT_2);
     if (!DBGApp) { 
    stringBuffer.append(TEXT_3);
     } 
    stringBuffer.append(TEXT_4);
    int XMC1xxx=-1;
    int Priority=0;
    int SubPriority=0;
    XMC1xxx=app.getSoftwareId().substring(0,1).compareTo("1");
    if(XMC1xxx!=0)
    {
     Priority = app.getIntegerValue(AppBaseuri + "/systm002_irwInterruptPriority"); 
     SubPriority = app.getIntegerValue(AppBaseuri + "/systm002_irwInterruptSubPriority"); 
    }
    else {
     Priority = app.getIntegerValue(AppBaseuri + "/systm002_irwInterruptPrio_timm"); 
    }
    stringBuffer.append(TEXT_5);
     if(XMC1xxx==0) { 
    stringBuffer.append(TEXT_6);
    stringBuffer.append( Priority );
    stringBuffer.append(TEXT_7);
     } else { 
    stringBuffer.append(TEXT_8);
    stringBuffer.append( Priority );
    stringBuffer.append(TEXT_9);
    stringBuffer.append( SubPriority );
    stringBuffer.append(TEXT_10);
    } 
    stringBuffer.append(TEXT_11);
    stringBuffer.append(TEXT_12);
    return stringBuffer.toString();
  }
}
