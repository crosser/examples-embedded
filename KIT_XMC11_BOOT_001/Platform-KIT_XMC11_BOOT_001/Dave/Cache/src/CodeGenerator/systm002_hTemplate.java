package CodeGenerator;

import com.ifx.davex.appjetinteract.App2JetInterface;

public class systm002_hTemplate
{
  protected static String nl;
  public static synchronized systm002_hTemplate create(String lineSeparator)
  {
    nl = lineSeparator;
    systm002_hTemplate result = new systm002_hTemplate();
    nl = null;
    return result;
  }

  public final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = "/*CODE_BLOCK_BEGIN[SYSTM002.h]*/" + NL + "/******************************************************************************" + NL + " * @file     SYSTM002.h" + NL + " * @brief    Simple System Timer App implementation header file." + NL + " *" + NL + " * @version  V1.0.0" + NL + " * @date     25 Sep 2013" + NL + " *" + NL + " * @note" + NL + " * Copyright (C) 2012-2013 Infineon Technologies AG. All rights reserved." + NL + "" + NL + " *" + NL + " * @par" + NL + " * Infineon Technologies AG (Infineon) is supplying this software for use with" + NL + " * Infineon's microcontrollers." + NL + " *" + NL + " * This file can be freely distributed within development tools that are" + NL + " * supporting such microcontrollers." + NL + " *" + NL + " *" + NL + " * @par" + NL + " * THIS SOFTWARE IS PROVIDED \"AS IS\".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED" + NL + " * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF" + NL + " * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE." + NL + " * INFINEON SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL," + NL + " * OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER." + NL + " *" + NL + " ******************************************************************************/" + NL + "/**************************** Change history ***********************************" + NL + " * V1.0.0,\t25-Sep-13\t Initial Version" + NL + "" + NL + " * *************************** Change history *********************************/" + NL + "" + NL + "" + NL + "#ifndef SYSTM002_H_" + NL + "#define SYSTM002_H_" + NL + "/* Inclusion of header file */" + NL + "#include <DAVE3.h>" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Global Macro Definitions                              **" + NL + "*******************************************************************************/" + NL + "" + NL + "/**" + NL + " * @ingroup SYSTM002_publicparam" + NL + " * @{" + NL + " */" + NL + "" + NL + "  /* System Core clock frequency in MHz */" + NL + "" + NL + "  ";
  protected final String TEXT_2 = NL + "#define SYSTM002_SYS_CORE_CLOCK  ";
  protected final String TEXT_3 = "U ";
  protected final String TEXT_4 = NL + "#define SYSTM002_SYS_CORE_CLOCK  ";
  protected final String TEXT_5 = " ";
  protected final String TEXT_6 = NL + NL + NL + "  /* Time between between two systick interrupt in Msec */";
  protected final String TEXT_7 = NL + "#define SYSTM002_SYSTICK_INTERVAL ";
  protected final String TEXT_8 = "U";
  protected final String TEXT_9 = NL + "#define SYSTM002_SYSTICK_INTERVAL 10";
  protected final String TEXT_10 = NL + "  /* Maximum No of timer */" + NL + "#define SYSTM002_CFG_MAX_TMR  ";
  protected final String TEXT_11 = "U " + NL + "" + NL + "/* Macro function to convert systick count to microsecond */" + NL + "#define CONVERT_SYSTICK_COUNT_TO_USEC(val) ( (val * SYSTM002_SYSTICK_INTERVAL)/1000U )" + NL + "/* Macro function to convert microsecond to systick count */" + NL + "#define CONVERT_USEC_TO_SYSICK_COUNT(val)   (SYSTM002_SYS_CORE_CLOCK * val)" + NL + "" + NL + "/**" + NL + " * @}" + NL + " */" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Global Type Definitions                               **" + NL + "*******************************************************************************/" + NL + "/**" + NL + " * @ingroup SYSTM002_publicparam" + NL + " * @{" + NL + " */" + NL + "" + NL + "/*" + NL + " * This enumeration define possible timer state." + NL + " */" + NL + "typedef enum SYSTM002_TimerStateType{" + NL + "/**" + NL + " * The timer is in running state" + NL + " */" + NL + "  SYSTM002_STATE_RUNNING," + NL + "/**" + NL + "  * The timer is stopped" + NL + " */" + NL + "  SYSTM002_STATE_STOPPED" + NL + "}SYSTM002_TimerStateType;" + NL + "" + NL + "/**" + NL + " * Enum values which describes timer types" + NL + " */" + NL + "typedef enum SYSTM002_TimerType" + NL + "{" + NL + "  /**" + NL + "    * Timer Type is one shot." + NL + "    */" + NL + "  SYSTM002_ONE_SHOT," + NL + "  /**" + NL + "   * Timer Type is periodic." + NL + "   */" + NL + "  SYSTM002_PERIODIC" + NL + "}SYSTM002_TimerType;" + NL + "" + NL + "" + NL + "" + NL + "/**" + NL + " * Enum values which describes return status of functions" + NL + " */" + NL + "typedef enum SYSTM002_ErrorCodesType" + NL + "{" + NL + "  /**" + NL + "   * Invalid Handle." + NL + "   */" + NL + "  /**" + NL + "   * @cond INTERNAL_DOCS" + NL + "   * @param MODULENAME SYSTM002" + NL + "   * @endcond" + NL + "  */" + NL + "  /**" + NL + "   * @cond INTERNAL_DOCS" + NL + "   * @param\tERRCODESTRING1 SYSTM002_INVALID_HANDLE_ERROR" + NL + "   * @param\tSTRCODESTRING1 Input handle is not valid" + NL + "   * @endcond" + NL + "  */" + NL + "  SYSTM002_INVALID_HANDLE_ERROR = 1," + NL + "  /**" + NL + "   * Timer error occured." + NL + "   */" + NL + "  /**" + NL + "   * @cond INTERNAL_DOCS" + NL + "   * @param\tERRCODESTRING2 SYSTM002_ERROR" + NL + "   * @param\tSTRCODESTRING2 Timer Error" + NL + "   * @endcond" + NL + "  */" + NL + "  SYSTM002_ERROR," + NL + "  /**" + NL + "   * Debuglog function entry." + NL + "   */" + NL + "  /**" + NL + "   * @cond INTERNAL_DOCS" + NL + "   * @param\tERRCODESTRING3 SYSTM002_FUNCTION_ENTRY" + NL + "   * @param\tSTRCODESTRING3 Entered function \\%s" + NL + "   * @endcond" + NL + "   *" + NL + "   */" + NL + "  SYSTM002_FUNCTION_ENTRY," + NL + "  /**" + NL + "   * Debuglog function exit." + NL + "   */" + NL + "  /**" + NL + "   * @cond INTERNAL_DOCS" + NL + "   * @param ERRCODESTRING4 SYSTM002_FUNCTION_EXIT" + NL + "   * @param STRCODESTRING4 Exited function \\%s" + NL + "   * @endcond" + NL + "  */" + NL + "  SYSTM002_FUNCTION_EXIT" + NL + "}SYSTM002_ErrorCodesType;" + NL + "" + NL + "" + NL + "/**" + NL + " * Timer callback function pointer." + NL + " */" + NL + "typedef void (*SYSTM002_TimerCallBackPtr)(void* ParamToCallBack);" + NL + "" + NL + "" + NL + "" + NL + "/**" + NL + " * Global structure which acts as the timer control block ." + NL + " *  " + NL + " */" + NL + "typedef struct SYSTM002_TimerObject" + NL + "{" + NL + "  /* <<<DD_SYSTM002_STRUCT_1>>> */" + NL + "  /** Timer ID  */" + NL + "  uint32_t TimerID;" + NL + "  /** Timer Type (Single Shot or Periodic)*/" + NL + "  SYSTM002_TimerType TimerType;" + NL + "  /** Timer State  */" + NL + "  SYSTM002_TimerStateType TimerState;" + NL + "  /** Timer Counter  */" + NL + "  uint32_t TimerCount;" + NL + "  /** Timer Reload Counter value */" + NL + "  uint32_t TimerReload;" + NL + "  /** Callback function pointer */" + NL + "  SYSTM002_TimerCallBackPtr TimerCallBack;" + NL + "  /** Parameter to callback function */" + NL + "  void* ParamToCallBack;" + NL + "  /** pointer to next timer control block*/" + NL + "  struct SYSTM002_TimerObject*  TimerNext;" + NL + "  /** Pointer to previous timer control block */" + NL + "  struct SYSTM002_TimerObject*  TimerPrev;" + NL + "}SYSTM002_TimerObject;" + NL + "" + NL + "" + NL + "/**" + NL + " * @}" + NL + " */" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Global Constant Declarations                          **" + NL + "*******************************************************************************/" + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Extern Variables                                      **" + NL + "*******************************************************************************/" + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + "**                     FUNCTION PROTOTYPES                                    **" + NL + "*******************************************************************************/" + NL + "/**" + NL + " * @ingroup SYSTM002_apidoc" + NL + " * @{" + NL + " */" + NL + "" + NL + "" + NL + "/**" + NL + " * Initializes the systick counter as per the systick interval specified by the " + NL + " * user and start the systick counter. It also initializes global variables." + NL + " *" + NL + " * @return     void" + NL + " *" + NL + " *" + NL + " * <b>Reentrant: NO </b><BR>" + NL + " * <BR><P ALIGN=\"LEFT\"><B>Example:</B>" + NL + " * @code" + NL + " *  #include <DAVE3.h>" + NL + " *  int main(void)" + NL + " *  {" + NL + " *    // Initialize and Systick counter" + NL + " *    DAVE_Init(); // SYSTM002_Init() will be called within DAVE_Init()" + NL + " *    // ... infinite loop ..." + NL + " *    while(1)" + NL + " *    {" + NL + " *    " + NL + " *    }" + NL + " *     " + NL + " *  }" + NL + " * @endcode<BR> </p>" + NL + " */" + NL + "void  SYSTM002_Init( void);" + NL + "" + NL + "" + NL + "/**" + NL + " *  Creates a new software Timer." + NL + " *  " + NL + " *  Note : This App uses SysTick Exception for controlling the timer list. Call back function" + NL + " *  registered through this function will be called in SysTick exception when the timer is expired." + NL + " *  One shot timers are removed from the timer list, if it expires. To use" + NL + " *  this SW timer again it has to be first deleted and then created again. " + NL + " *  Periodic timer will be added again to the timer list with the same periodic" + NL + " *  value after it expires." + NL + " *" + NL + " *" + NL + " * @param[in]  Period Timer period value in microseconds" + NL + " * @param[in]  TimerType Type of Timer(ONE_SHOT/PERIODIC)" + NL + " * @param[in]  TimerCallBack Call back function of the timer(No Macros are allowed)" + NL + " * @param[in]  pCallBackArgPtr Call back function parameter" + NL + " *" + NL + " * @return     handle_t<BR> " + NL + " *             Timer ID : If timer created successfully.<BR>" + NL + " *             0  : If timer creation failed.<BR>" + NL + " *" + NL + " *" + NL + " * <b>Reentrant: NO </b><BR>" + NL + " *" + NL + " * <BR><P ALIGN=\"LEFT\"><B>Example:</B>" + NL + " * @code" + NL + " *  #include <DAVE3.h>" + NL + " * static volatile bool TimerExpired;" + NL + " * void my_func_a(void* Temp)" + NL + " *  {" + NL + " *    static uint32_t Count = 1;" + NL + " *    if(Count == 10)" + NL + " *    {" + NL + " *      TimerExpired = TRUE;" + NL + " *    }" + NL + " *    Count++;" + NL + " *  }" + NL + " *  int main(void)" + NL + " *  {" + NL + " *    handle_t TimerId;" + NL + " *    // ... Initializes Apps configurations ..." + NL + " *    DAVE_Init();" + NL + " *    TimerId = SYSTM002_CreateTimer(100,SYSTM002_PERIODIC,my_func_a,NULL);" + NL + " *    if(TimerId != 0)" + NL + " *    {" + NL + " *    //Timer is created successfully" + NL + " *    }" + NL + " *    // ... infinite loop ..." + NL + " *    while(1)" + NL + " *    {" + NL + " *    " + NL + " *    }" + NL + " *     " + NL + " *  }" + NL + " * @endcode<BR> </p>" + NL + " */" + NL + "handle_t SYSTM002_CreateTimer" + NL + "(" + NL + "  uint32_t Period," + NL + "  SYSTM002_TimerType TimerType," + NL + "  SYSTM002_TimerCallBackPtr TimerCallBack," + NL + "  void  * pCallBackArgPtr" + NL + ");" + NL + "" + NL + "/**" + NL + " * Starts the software timer ." + NL + " *" + NL + " *" + NL + " * @param[in]  Handle Timer ID obtained from SYSTM002_CreateTimer" + NL + " *" + NL + " * @return     status_t<BR>" + NL + " *             DAVEApp_SUCCESS \t\t\t: If timer is started successufully<BR>" + NL + " *             SYSTM002_INVALID_HANDLE  : If Timer ID  passed is invalid<BR>" + NL + " *" + NL + " * <b>Reentrant: NO </b><BR>" + NL + " *" + NL + " * <BR><P ALIGN=\"LEFT\"><B>Example:</B>" + NL + " * @code" + NL + " *  #include <DAVE3.h>" + NL + " *  static volatile bool TimerExpired; " + NL + " *  void my_func_a(void* Temp)" + NL + " *  {" + NL + " *    static uint32_t Count = 1;" + NL + " *    if(Count == 10)" + NL + " *    {" + NL + " *      TimerExpired = TRUE;" + NL + " *    }" + NL + " *    Count++;" + NL + " *  }" + NL + " *  int main(void)" + NL + " *  {" + NL + " *    handle_t TimerId;" + NL + " *    uint32_t Status = SYSTM002_ERROR;" + NL + " *    // ... Initializes Apps configurations ..." + NL + " *    DAVE_Init();" + NL + " *    TimerId = SYSTM002_CreateTimer(100,SYSTM002_PERIODIC,my_func_a,NULL);" + NL + " *    if(TimerId != 0)" + NL + " *    {" + NL + " *      //Timer is created successfully" + NL + " *   \tStatus = SYSTM002_StartTimer(TimerId);" + NL + " *   \tif(Status == DAVEApp_SUCCESS)" + NL + " *   \t{" + NL + " *   \t         //Timer started" + NL + " *   \t}" + NL + " *\t  }" + NL + " *    // ... infinite loop ..." + NL + " *    while(1)" + NL + " *    {" + NL + " *    " + NL + " *    }" + NL + " *  }" + NL + " * @endcode<BR> </p>" + NL + " */" + NL + "status_t SYSTM002_StartTimer(handle_t  Handle) ;" + NL + "" + NL + "" + NL + "/**" + NL + " * Stops the software timer" + NL + " *" + NL + " * @param[in]  Handle Timer ID obtained from SYSTM002_CreateTimer" + NL + " *" + NL + " * @return     status_t<BR>" + NL + " *             DAVEApp_SUCCESS \t\t\t: if timer is stopped successfully.<BR>" + NL + " *             SYSTM002_INVALID_HANDLE  : If Timer ID  passed is invalid.<BR>" + NL + " *" + NL + " * <b>Reentrant: NO </b><BR>" + NL + " *" + NL + " * <BR><P ALIGN=\"LEFT\"><B>Example:</B>" + NL + " * @code" + NL + " *  #include <DAVE3.h>" + NL + " *  static volatile bool TimerExpired;" + NL + " *  void my_func_a(void* Temp)" + NL + " *  {" + NL + " *   static uint32_t Count = 1;" + NL + " *   if(Count == 10)" + NL + " *   {" + NL + " *     TimerExpired = TRUE;" + NL + " *   }" + NL + " *    Count++;" + NL + " *  }" + NL + " *  int main(void)" + NL + " *  {" + NL + " *    handle_t TimerId;" + NL + " *   uint32_t Status = SYSTM002_ERROR;" + NL + " *   // ... Initializes Apps configurations ..." + NL + " *    DAVE_Init();" + NL + " *    TimerId = SYSTM002_CreateTimer(100,SYSTM002_PERIODIC,my_func_a,NULL);" + NL + " *    if(TimerId != 0)" + NL + " *    {" + NL + " *      //Timer is created successfully" + NL + " *    \tStatus = SYSTM002_StartTimer(TimerId);" + NL + " *      if(Status == DAVEApp_SUCCESS)" + NL + " *    \t{" + NL + " *    \t   // Wait till timer is expired" + NL + " *    \t   while(TimerExpired == FALSE)" + NL + " *         {}" + NL + " *    \t\t//stop the timer" + NL + " *    \t\tStatus = SYSTM002_StopTimer(TimerId);" + NL + " *    \t    if(Status == DAVEApp_SUCCESS)" + NL + " *    \t\t{" + NL + " *    \t      //Timer stopped" + NL + " *    \t\t}" + NL + " *       }" + NL + " *       // start the timer" + NL + " *        SYSTM002_StartTimer(TimerId);" + NL + " *    }" + NL + " *    // ... infinite loop ..." + NL + " *    while(1)" + NL + " *    {" + NL + " *     " + NL + " *    }" + NL + " *      " + NL + " * }" + NL + " * @endcode<BR> </p>" + NL + " */" + NL + "status_t SYSTM002_StopTimer(handle_t Handle) ;" + NL + "" + NL + "/**" + NL + " * Deletes the software timer from the timer list." + NL + " *  " + NL + " *  Note : One shot timers are removed from the timer list, if it expires. To use " + NL + " *  this SW timer again it have to be first deleted and then created again. " + NL + " *  Periodic timer will be added again to the timer list with the same periodic" + NL + " *  value after it expires." + NL + " *" + NL + " *" + NL + " * @param[in]  Handle Timer ID" + NL + " *" + NL + " * @return     status_t<BR>" + NL + " *             DAVEApp_SUCCESS \t\t\t: if timer is deleted successufully.<BR>" + NL + " *             SYSTM002_INVALID_HANDLE  : If Timer ID  passed is invalid.<BR>" + NL + " *" + NL + " * <b>Reentrant: NO </b><BR>" + NL + " *" + NL + " * <BR><P ALIGN=\"LEFT\"><B>Example:</B>" + NL + " * @code" + NL + " *  #include <DAVE3.h>" + NL + " *  static volatile bool TimerExpired;" + NL + " *  void my_func_a(void* Temp)" + NL + " *  {" + NL + " *   static uint32_t Count = 1;" + NL + " *   if(Count == 10)" + NL + " *   {" + NL + " *     TimerExpired = TRUE;" + NL + " *   }" + NL + " *   Count++;" + NL + " *  }" + NL + " *  int main(void)" + NL + " *  {" + NL + " *    handle_t TimerId;" + NL + " *    uint32_t Status = SYSTM002_ERROR;" + NL + " *    // ... Initializes Apps configurations ..." + NL + " *    DAVE_Init();" + NL;
  protected final String TEXT_12 = " *    TimerId = SYSTM002_CreateTimer(100,SYSTM002_PERIODIC,my_func_a,NULL);" + NL + " *    if(TimerId != 0)" + NL + " *    {" + NL + " *      //Timer is created successfully" + NL + " *      Status = SYSTM002_StartTimer(TimerId);" + NL + " *      if(Status == DAVEApp_SUCCESS)" + NL + " *    \t{" + NL + " *        // Wait till timer is expired" + NL + " *        while(TimerExpired == FALSE)" + NL + " *        {}" + NL + " *    \t  //stop the timer" + NL + " *    \t  Status = SYSTM002_StopTimer(TimerId);" + NL + " *        if(Status == DAVEApp_SUCCESS)" + NL + " *    \t  {" + NL + " *    \t    SYSTM002_DeleteTimer(TimerId);" + NL + " *    \t  }" + NL + " *      }" + NL + " *    }    " + NL + " *    // ... infinite loop ..." + NL + " *    while(1)" + NL + " *    {" + NL + " *     " + NL + " *    } " + NL + " * }" + NL + " * @endcode<BR> </p>" + NL + " */" + NL + "status_t SYSTM002_DeleteTimer(handle_t Handle) ;" + NL + "" + NL + "" + NL + "/**" + NL + " * Gives the current system time in microsec since start of counter." + NL + " *" + NL + " *" + NL + " * @return     uint32_t returns current system time in microsec." + NL + " *" + NL + " *" + NL + " * <b>Reentrant: NO </b><BR>" + NL + " *" + NL + " * <BR><P ALIGN=\"LEFT\"><B>Example:</B>" + NL + " * @code" + NL + " *  #include <DAVE3.h>" + NL + " *  static volatile bool TimerExpired; " + NL + " *  void my_func_a(void* Temp)" + NL + " *  {" + NL + " *    static uint32_t Count = 1;" + NL + " * \t  if(Count == 10)" + NL + " *    {" + NL + " *      TimerExpired = TRUE;" + NL + " *    }" + NL + " *    Count++;" + NL + " *  }" + NL + " *  int main(void)" + NL + " *  {" + NL + " * \t  handle_t TimerId;" + NL + " *    uint32_t SystemTime = 0;" + NL + " *    uint32_t Status = SYSTM002_ERROR;" + NL + " *    // ... Initializes Apps configurations ..." + NL + " *    DAVE_Init();" + NL + " *    TimerId = SYSTM002_CreateTimer(100,SYSTM002_PERIODIC,my_func_a,NULL);" + NL + " *    if(TimerId != 0)" + NL + " *    {" + NL + " *      //Timer is created successfully" + NL + " *      Status = SYSTM002_StartTimer(TimerId);" + NL + " *      if(Status == DAVEApp_SUCCESS)" + NL + " *      {" + NL + " *        SystemTime = SYSTM002_GetTime();" + NL + " *      }" + NL + " *    }" + NL + " *     // ... infinite loop ..." + NL + " *    while(1)" + NL + " *    {" + NL + " *    " + NL + " *    }" + NL + " * }" + NL + " * @endcode<BR> </p>" + NL + " */" + NL + "uint32_t  SYSTM002_GetTime(void);" + NL + "" + NL + "" + NL + "/**" + NL + " * Utility function to get the no of system ticks for the" + NL + " * specified period given in microsec." + NL + " *" + NL + " *" + NL + " * @return     uint32_t returns no of system ticks" + NL + " *" + NL + " *" + NL + " * <b>Reentrant: NO </b><BR>" + NL + " *" + NL + " * <BR><P ALIGN=\"LEFT\"><B>Example:</B>" + NL + " * @code" + NL + " *  #include <DAVE3.h>" + NL + " *  int main(void)" + NL + " *  {" + NL + " *    uint32_t SysTickCount = 0;" + NL + " *    DAVE_Init();" + NL + " *    // Get systick timer count value for 100microsec" + NL + " *    SysTickCount = SYSTM002_GetSysTickCount(100);" + NL + " *    return 0;" + NL + " *  }" + NL + " * @endcode<BR> </p>" + NL + " */" + NL + "uint32_t  SYSTM002_GetSysTickCount(uint32_t Period );" + NL + "" + NL + "/**" + NL + " *@}" + NL + " */" + NL + "" + NL + "#endif /* SYSTM002_H_ */   " + NL + "" + NL + "/*CODE_BLOCK_END*/";

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
     App2JetInterface app = (App2JetInterface) argument; 
     String AppBaseuri = "app/systm002/0";
    stringBuffer.append(TEXT_1);
    int XMC1xxx=-1;
    XMC1xxx=app.getSoftwareId().substring(0,1).compareTo("1");
    if(XMC1xxx!=0)
    {
    stringBuffer.append(TEXT_2);
    stringBuffer.append( app.getIntegerValue (AppBaseuri + "/clockapp/clk001_iroActualFreqSystem" ) );
    stringBuffer.append(TEXT_3);
    }
    else {
    stringBuffer.append(TEXT_4);
    stringBuffer.append( app.getDoubleValue (AppBaseuri + "/clockapp/clk002_irMCLK" ) );
    stringBuffer.append(TEXT_5);
    }
    stringBuffer.append(TEXT_6);
    int systick = app.getIntegerValue (AppBaseuri + "/systm002_systickinterval" );
if(systick > 0) {
    stringBuffer.append(TEXT_7);
    stringBuffer.append(systick);
    stringBuffer.append(TEXT_8);
    }else {
    stringBuffer.append(TEXT_9);
    }
    stringBuffer.append(TEXT_10);
    stringBuffer.append( app.getIntegerValue (AppBaseuri + "/systm002_swtimers" ) );
    stringBuffer.append(TEXT_11);
    stringBuffer.append(TEXT_12);
    return stringBuffer.toString();
  }
}
